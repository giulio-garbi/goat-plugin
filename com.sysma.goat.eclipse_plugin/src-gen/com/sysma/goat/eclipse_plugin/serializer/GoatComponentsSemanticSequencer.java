/*
 * generated by Xtext 2.12.0
 */
package com.sysma.goat.eclipse_plugin.serializer;

import com.google.inject.Inject;
import com.sysma.goat.eclipse_plugin.goatComponents.And;
import com.sysma.goat.eclipse_plugin.goatComponents.BoolConstant;
import com.sysma.goat.eclipse_plugin.goatComponents.Comparison;
import com.sysma.goat.eclipse_plugin.goatComponents.ComponentAttributeRef;
import com.sysma.goat.eclipse_plugin.goatComponents.ComponentDefinition;
import com.sysma.goat.eclipse_plugin.goatComponents.Concatenate;
import com.sysma.goat.eclipse_plugin.goatComponents.ContainmentExpression;
import com.sysma.goat.eclipse_plugin.goatComponents.EnvParam;
import com.sysma.goat.eclipse_plugin.goatComponents.Environment;
import com.sysma.goat.eclipse_plugin.goatComponents.EnvironmentArg;
import com.sysma.goat.eclipse_plugin.goatComponents.EnvironmentDefinition;
import com.sysma.goat.eclipse_plugin.goatComponents.Equality;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncBlock;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncDefinition;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncIfElse;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncParam;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncReturn;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncVarAppend;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncVarAssign;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncVarDeclaration;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncVarPop;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncWhile;
import com.sysma.goat.eclipse_plugin.goatComponents.FunctionCall;
import com.sysma.goat.eclipse_plugin.goatComponents.GoatComponentsPackage;
import com.sysma.goat.eclipse_plugin.goatComponents.IntConstant;
import com.sysma.goat.eclipse_plugin.goatComponents.LocalAttributeRef;
import com.sysma.goat.eclipse_plugin.goatComponents.LocalVarRef;
import com.sysma.goat.eclipse_plugin.goatComponents.Minus;
import com.sysma.goat.eclipse_plugin.goatComponents.Model;
import com.sysma.goat.eclipse_plugin.goatComponents.MulOrDiv;
import com.sysma.goat.eclipse_plugin.goatComponents.NegativeIntConstant;
import com.sysma.goat.eclipse_plugin.goatComponents.Not;
import com.sysma.goat.eclipse_plugin.goatComponents.Or;
import com.sysma.goat.eclipse_plugin.goatComponents.OutEqualityComparison;
import com.sysma.goat.eclipse_plugin.goatComponents.Plus;
import com.sysma.goat.eclipse_plugin.goatComponents.PrintAllStatement;
import com.sysma.goat.eclipse_plugin.goatComponents.PrintFormattedStatement;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessBlock;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessCall;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessDefinition;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessIf;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessLoop;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessReceiveMultiple;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessReceiveSingle;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessSend;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessSet;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessSpawn;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessWaitFor;
import com.sysma.goat.eclipse_plugin.goatComponents.RecAttributeRef;
import com.sysma.goat.eclipse_plugin.goatComponents.ReceiveCase;
import com.sysma.goat.eclipse_plugin.goatComponents.StringConstant;
import com.sysma.goat.eclipse_plugin.goatComponents.TupleConstant;
import com.sysma.goat.eclipse_plugin.goatComponents.TupleGet;
import com.sysma.goat.eclipse_plugin.goatComponents.TupleLength;
import com.sysma.goat.eclipse_plugin.goatComponents.UnaryMinus;
import com.sysma.goat.eclipse_plugin.goatComponents.Update;
import com.sysma.goat.eclipse_plugin.goatComponents.UpdateComponentAttribute;
import com.sysma.goat.eclipse_plugin.goatComponents.UpdateLocalAttribute;
import com.sysma.goat.eclipse_plugin.services.GoatComponentsGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GoatComponentsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GoatComponentsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GoatComponentsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GoatComponentsPackage.AND:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()) {
					sequence_And(context, (And) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOutputPredicateRule()
						|| rule == grammarAccess.getOutOrRule()
						|| action == grammarAccess.getOutOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getOutAndRule()
						|| action == grammarAccess.getOutAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getOutEqualityComparisonRule()
						|| rule == grammarAccess.getOutPrimaryRule()) {
					sequence_OutAnd(context, (And) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.BOOL_CONSTANT:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (BoolConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEnvInitValueRule()
						|| rule == grammarAccess.getEnvInitOrArgRule()) {
					sequence_EnvInitValue(context, (BoolConstant) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getOutEqualityComparisonAccess().getOutEqualityComparisonLeftAction_1_1_0_0()
						|| action == grammarAccess.getOutEqualityComparisonAccess().getContainmentExpressionElemAction_1_1_1_0()
						|| rule == grammarAccess.getOutAtomicOrRecRule()
						|| rule == grammarAccess.getOutAtomicRule()) {
					sequence_OutAtomic(context, (BoolConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOutputPredicateRule()
						|| rule == grammarAccess.getOutOrRule()
						|| action == grammarAccess.getOutOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getOutAndRule()
						|| action == grammarAccess.getOutAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getOutEqualityComparisonRule()
						|| rule == grammarAccess.getOutPrimaryRule()) {
					sequence_OutPrimary(context, (BoolConstant) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case GoatComponentsPackage.COMPONENT_ATTRIBUTE_REF:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()
						|| rule == grammarAccess.getAtomicRule()
						|| action == grammarAccess.getAtomicAccess().getTupleGetElemAction_3_1_1()
						|| rule == grammarAccess.getAtomicIndexableRule()) {
					sequence_AtomicIndexable(context, (ComponentAttributeRef) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getOutEqualityComparisonAccess().getOutEqualityComparisonLeftAction_1_1_0_0()
						|| action == grammarAccess.getOutEqualityComparisonAccess().getContainmentExpressionElemAction_1_1_1_0()
						|| rule == grammarAccess.getOutAtomicOrRecRule()
						|| rule == grammarAccess.getOutAtomicRule()
						|| action == grammarAccess.getOutAtomicAccess().getTupleGetElemAction_3_1_1()
						|| rule == grammarAccess.getOutAtomicIndexableRule()) {
					sequence_OutAtomicIndexable(context, (ComponentAttributeRef) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.COMPONENT_DEFINITION:
				sequence_ComponentDefinition(context, (ComponentDefinition) semanticObject); 
				return; 
			case GoatComponentsPackage.CONCATENATE:
				sequence_PlusOrMinus(context, (Concatenate) semanticObject); 
				return; 
			case GoatComponentsPackage.CONTAINMENT_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()) {
					sequence_ContainmentExpr(context, (ContainmentExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOCERule()) {
					sequence_OCE(context, (ContainmentExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOutputPredicateRule()
						|| rule == grammarAccess.getOutOrRule()
						|| action == grammarAccess.getOutOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getOutAndRule()
						|| action == grammarAccess.getOutAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getOutEqualityComparisonRule()
						|| rule == grammarAccess.getOutPrimaryRule()) {
					sequence_OutEqualityComparison(context, (ContainmentExpression) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.ENV_PARAM:
				sequence_EnvParam(context, (EnvParam) semanticObject); 
				return; 
			case GoatComponentsPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case GoatComponentsPackage.ENVIRONMENT_ARG:
				sequence_EnvInitOrArg(context, (EnvironmentArg) semanticObject); 
				return; 
			case GoatComponentsPackage.ENVIRONMENT_DEFINITION:
				sequence_EnvironmentDefinition(context, (EnvironmentDefinition) semanticObject); 
				return; 
			case GoatComponentsPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_BLOCK:
				sequence_FuncBlock(context, (FuncBlock) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_DEFINITION:
				sequence_FuncDefinition(context, (FuncDefinition) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_IF_ELSE:
				sequence_FuncIfElse(context, (FuncIfElse) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_PARAM:
				sequence_FuncParam(context, (FuncParam) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_RETURN:
				sequence_FuncReturn(context, (FuncReturn) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_VAR_APPEND:
				sequence_FuncVarAppend(context, (FuncVarAppend) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_VAR_ASSIGN:
				sequence_FuncVarAssign(context, (FuncVarAssign) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_VAR_DECLARATION:
				sequence_FuncVarDeclaration(context, (FuncVarDeclaration) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_VAR_POP:
				sequence_FuncVarPop(context, (FuncVarPop) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_WHILE:
				sequence_FuncWhile(context, (FuncWhile) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNCTION_CALL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()
						|| rule == grammarAccess.getAtomicRule()
						|| action == grammarAccess.getAtomicAccess().getTupleGetElemAction_3_1_1()
						|| rule == grammarAccess.getAtomicIndexableRule()) {
					sequence_AtomicIndexable(context, (FunctionCall) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getOutEqualityComparisonAccess().getOutEqualityComparisonLeftAction_1_1_0_0()
						|| action == grammarAccess.getOutEqualityComparisonAccess().getContainmentExpressionElemAction_1_1_1_0()
						|| rule == grammarAccess.getOutAtomicOrRecRule()
						|| rule == grammarAccess.getOutAtomicRule()
						|| action == grammarAccess.getOutAtomicAccess().getTupleGetElemAction_3_1_1()
						|| rule == grammarAccess.getOutAtomicIndexableRule()) {
					sequence_OutAtomicIndexable(context, (FunctionCall) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.INT_CONSTANT:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (IntConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEnvInitValueRule()
						|| rule == grammarAccess.getEnvInitOrArgRule()) {
					sequence_EnvInitValue(context, (IntConstant) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getOutEqualityComparisonAccess().getOutEqualityComparisonLeftAction_1_1_0_0()
						|| action == grammarAccess.getOutEqualityComparisonAccess().getContainmentExpressionElemAction_1_1_1_0()
						|| rule == grammarAccess.getOutAtomicOrRecRule()
						|| rule == grammarAccess.getOutAtomicRule()) {
					sequence_OutAtomic(context, (IntConstant) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.LOCAL_ATTRIBUTE_REF:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()
						|| rule == grammarAccess.getAtomicRule()
						|| action == grammarAccess.getAtomicAccess().getTupleGetElemAction_3_1_1()
						|| rule == grammarAccess.getAtomicIndexableRule()) {
					sequence_AtomicIndexable(context, (LocalAttributeRef) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getOutEqualityComparisonAccess().getOutEqualityComparisonLeftAction_1_1_0_0()
						|| action == grammarAccess.getOutEqualityComparisonAccess().getContainmentExpressionElemAction_1_1_1_0()
						|| rule == grammarAccess.getOutAtomicOrRecRule()
						|| rule == grammarAccess.getOutAtomicRule()
						|| action == grammarAccess.getOutAtomicAccess().getTupleGetElemAction_3_1_1()
						|| rule == grammarAccess.getOutAtomicIndexableRule()) {
					sequence_OutAtomicIndexable(context, (LocalAttributeRef) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.LOCAL_VAR_REF:
				sequence_AtomicIndexable(context, (LocalVarRef) semanticObject); 
				return; 
			case GoatComponentsPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case GoatComponentsPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case GoatComponentsPackage.MUL_OR_DIV:
				sequence_MulOrDiv(context, (MulOrDiv) semanticObject); 
				return; 
			case GoatComponentsPackage.NEGATIVE_INT_CONSTANT:
				sequence_EnvInitValue(context, (NegativeIntConstant) semanticObject); 
				return; 
			case GoatComponentsPackage.NOT:
				if (rule == grammarAccess.getOutputPredicateRule()
						|| rule == grammarAccess.getOutOrRule()
						|| action == grammarAccess.getOutOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getOutAndRule()
						|| action == grammarAccess.getOutAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getOutEqualityComparisonRule()
						|| rule == grammarAccess.getOutPrimaryRule()) {
					sequence_OutPrimary(context, (Not) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()) {
					sequence_Primary(context, (Not) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.OR:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()) {
					sequence_Or(context, (Or) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOutputPredicateRule()
						|| rule == grammarAccess.getOutOrRule()
						|| action == grammarAccess.getOutOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getOutAndRule()
						|| action == grammarAccess.getOutAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getOutEqualityComparisonRule()
						|| rule == grammarAccess.getOutPrimaryRule()) {
					sequence_OutOr(context, (Or) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.OUT_EQUALITY_COMPARISON:
				sequence_OutEqualityComparison(context, (OutEqualityComparison) semanticObject); 
				return; 
			case GoatComponentsPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case GoatComponentsPackage.PRINT_ALL_STATEMENT:
				sequence_PrintAllStatement(context, (PrintAllStatement) semanticObject); 
				return; 
			case GoatComponentsPackage.PRINT_FORMATTED_STATEMENT:
				sequence_PrintFormattedStatement(context, (PrintFormattedStatement) semanticObject); 
				return; 
			case GoatComponentsPackage.PROCESS_BLOCK:
				if (rule == grammarAccess.getEmptyProcessBlockRule()) {
					sequence_EmptyProcessBlock(context, (ProcessBlock) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPDPBlockRule()) {
					sequence_PDPBlock(context, (ProcessBlock) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPTBThenRule()) {
					sequence_PTBThen(context, (ProcessBlock) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getProcessBlockRule()) {
					sequence_ProcessBlock(context, (ProcessBlock) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.PROCESS_CALL:
				if (rule == grammarAccess.getPDPCallRule()) {
					sequence_PDPCall(context, (ProcessCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getProcessStatementRule()
						|| rule == grammarAccess.getProcessCallRule()) {
					sequence_ProcessCall(context, (ProcessCall) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.PROCESS_DEFINITION:
				sequence_ProcessDefinition(context, (ProcessDefinition) semanticObject); 
				return; 
			case GoatComponentsPackage.PROCESS_IF:
				sequence_ProcessIf_ProcessThenBlock(context, (ProcessIf) semanticObject); 
				return; 
			case GoatComponentsPackage.PROCESS_LOOP:
				sequence_ProcessLoop(context, (ProcessLoop) semanticObject); 
				return; 
			case GoatComponentsPackage.PROCESS_RECEIVE_MULTIPLE:
				sequence_ProcessReceiveMultiple(context, (ProcessReceiveMultiple) semanticObject); 
				return; 
			case GoatComponentsPackage.PROCESS_RECEIVE_SINGLE:
				sequence_ProcessReceiveSingle(context, (ProcessReceiveSingle) semanticObject); 
				return; 
			case GoatComponentsPackage.PROCESS_SEND:
				sequence_ProcessSend(context, (ProcessSend) semanticObject); 
				return; 
			case GoatComponentsPackage.PROCESS_SET:
				sequence_ProcessSet(context, (ProcessSet) semanticObject); 
				return; 
			case GoatComponentsPackage.PROCESS_SPAWN:
				if (rule == grammarAccess.getPDPSpawnRule()) {
					sequence_PDPSpawn(context, (ProcessSpawn) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getProcessStatementRule()
						|| rule == grammarAccess.getProcessSpawnRule()) {
					sequence_ProcessSpawn(context, (ProcessSpawn) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.PROCESS_WAIT_FOR:
				sequence_ProcessWaitFor(context, (ProcessWaitFor) semanticObject); 
				return; 
			case GoatComponentsPackage.REC_ATTRIBUTE_REF:
				sequence_OutAtomicOrRec(context, (RecAttributeRef) semanticObject); 
				return; 
			case GoatComponentsPackage.RECEIVE_CASE:
				sequence_ReceiveCase(context, (ReceiveCase) semanticObject); 
				return; 
			case GoatComponentsPackage.STRING_CONSTANT:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (StringConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEnvInitValueRule()
						|| rule == grammarAccess.getEnvInitOrArgRule()) {
					sequence_EnvInitValue(context, (StringConstant) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getOutEqualityComparisonAccess().getOutEqualityComparisonLeftAction_1_1_0_0()
						|| action == grammarAccess.getOutEqualityComparisonAccess().getContainmentExpressionElemAction_1_1_1_0()
						|| rule == grammarAccess.getOutAtomicOrRecRule()
						|| rule == grammarAccess.getOutAtomicRule()) {
					sequence_OutAtomic(context, (StringConstant) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.TUPLE_CONSTANT:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()
						|| rule == grammarAccess.getAtomicRule()
						|| action == grammarAccess.getAtomicAccess().getTupleGetElemAction_3_1_1()
						|| rule == grammarAccess.getAtomicIndexableRule()) {
					sequence_AtomicIndexable(context, (TupleConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEnvInitValueRule()
						|| rule == grammarAccess.getEnvInitOrArgRule()) {
					sequence_EnvInitValue(context, (TupleConstant) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getOutEqualityComparisonAccess().getOutEqualityComparisonLeftAction_1_1_0_0()
						|| action == grammarAccess.getOutEqualityComparisonAccess().getContainmentExpressionElemAction_1_1_1_0()
						|| rule == grammarAccess.getOutAtomicOrRecRule()
						|| rule == grammarAccess.getOutAtomicRule()
						|| action == grammarAccess.getOutAtomicAccess().getTupleGetElemAction_3_1_1()
						|| rule == grammarAccess.getOutAtomicIndexableRule()) {
					sequence_OutAtomicIndexable(context, (TupleConstant) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.TUPLE_GET:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (TupleGet) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getOutEqualityComparisonAccess().getOutEqualityComparisonLeftAction_1_1_0_0()
						|| action == grammarAccess.getOutEqualityComparisonAccess().getContainmentExpressionElemAction_1_1_1_0()
						|| rule == grammarAccess.getOutAtomicOrRecRule()
						|| rule == grammarAccess.getOutAtomicRule()) {
					sequence_OutAtomic(context, (TupleGet) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.TUPLE_LENGTH:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrSubAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndSubAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusOrMinusRule()
						|| action == grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0()
						|| action == grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0()
						|| rule == grammarAccess.getMulOrDivRule()
						|| action == grammarAccess.getMulOrDivAccess().getMulOrDivLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getContainmentExprRule()
						|| action == grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0()
						|| rule == grammarAccess.getAtomicOrExprRule()
						|| rule == grammarAccess.getAtomicRule()
						|| action == grammarAccess.getAtomicAccess().getTupleGetElemAction_3_1_1()
						|| rule == grammarAccess.getAtomicIndexableRule()) {
					sequence_AtomicIndexable(context, (TupleLength) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getOutEqualityComparisonAccess().getOutEqualityComparisonLeftAction_1_1_0_0()
						|| action == grammarAccess.getOutEqualityComparisonAccess().getContainmentExpressionElemAction_1_1_1_0()
						|| rule == grammarAccess.getOutAtomicOrRecRule()
						|| rule == grammarAccess.getOutAtomicRule()
						|| action == grammarAccess.getOutAtomicAccess().getTupleGetElemAction_3_1_1()
						|| rule == grammarAccess.getOutAtomicIndexableRule()) {
					sequence_OutAtomicIndexable(context, (TupleLength) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.UNARY_MINUS:
				sequence_Primary(context, (UnaryMinus) semanticObject); 
				return; 
			case GoatComponentsPackage.UPDATE:
				sequence_Update(context, (Update) semanticObject); 
				return; 
			case GoatComponentsPackage.UPDATE_COMPONENT_ATTRIBUTE:
				sequence_UpdateComponentAttribute(context, (UpdateComponentAttribute) semanticObject); 
				return; 
			case GoatComponentsPackage.UPDATE_LOCAL_ATTRIBUTE:
				sequence_UpdateLocalAttribute(context, (UpdateLocalAttribute) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     PlusOrMinus returns And
	 *     PlusOrMinus.Plus_1_0_0_0 returns And
	 *     PlusOrMinus.Minus_1_0_1_0 returns And
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns And
	 *     MulOrDiv returns And
	 *     MulOrDiv.MulOrDiv_1_0 returns And
	 *     Primary returns And
	 *     ContainmentExpr returns And
	 *     ContainmentExpr.ContainmentExpression_1_0 returns And
	 *     AtomicOrExpr returns And
	 *
	 * Constraint:
	 *     (sub+=And_And_1_0 sub+=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ComponentAttributeRef
	 *     Or returns ComponentAttributeRef
	 *     Or.Or_1_0 returns ComponentAttributeRef
	 *     And returns ComponentAttributeRef
	 *     And.And_1_0 returns ComponentAttributeRef
	 *     Equality returns ComponentAttributeRef
	 *     Equality.Equality_1_0 returns ComponentAttributeRef
	 *     Comparison returns ComponentAttributeRef
	 *     Comparison.Comparison_1_0 returns ComponentAttributeRef
	 *     PlusOrMinus returns ComponentAttributeRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns ComponentAttributeRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns ComponentAttributeRef
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns ComponentAttributeRef
	 *     MulOrDiv returns ComponentAttributeRef
	 *     MulOrDiv.MulOrDiv_1_0 returns ComponentAttributeRef
	 *     Primary returns ComponentAttributeRef
	 *     ContainmentExpr returns ComponentAttributeRef
	 *     ContainmentExpr.ContainmentExpression_1_0 returns ComponentAttributeRef
	 *     AtomicOrExpr returns ComponentAttributeRef
	 *     Atomic returns ComponentAttributeRef
	 *     Atomic.TupleGet_3_1_1 returns ComponentAttributeRef
	 *     AtomicIndexable returns ComponentAttributeRef
	 *
	 * Constraint:
	 *     attribute=ID
	 */
	protected void sequence_AtomicIndexable(ISerializationContext context, ComponentAttributeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.COMPONENT_ATTRIBUTE_REF__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.COMPONENT_ATTRIBUTE_REF__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicIndexableAccess().getAttributeIDTerminalRuleCall_5_3_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionCall
	 *     Or returns FunctionCall
	 *     Or.Or_1_0 returns FunctionCall
	 *     And returns FunctionCall
	 *     And.And_1_0 returns FunctionCall
	 *     Equality returns FunctionCall
	 *     Equality.Equality_1_0 returns FunctionCall
	 *     Comparison returns FunctionCall
	 *     Comparison.Comparison_1_0 returns FunctionCall
	 *     PlusOrMinus returns FunctionCall
	 *     PlusOrMinus.Plus_1_0_0_0 returns FunctionCall
	 *     PlusOrMinus.Minus_1_0_1_0 returns FunctionCall
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns FunctionCall
	 *     MulOrDiv returns FunctionCall
	 *     MulOrDiv.MulOrDiv_1_0 returns FunctionCall
	 *     Primary returns FunctionCall
	 *     ContainmentExpr returns FunctionCall
	 *     ContainmentExpr.ContainmentExpression_1_0 returns FunctionCall
	 *     AtomicOrExpr returns FunctionCall
	 *     Atomic returns FunctionCall
	 *     Atomic.TupleGet_3_1_1 returns FunctionCall
	 *     AtomicIndexable returns FunctionCall
	 *
	 * Constraint:
	 *     (function=[FuncDefinition|ID] (params+=Expression params+=Expression*)?)
	 */
	protected void sequence_AtomicIndexable(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LocalAttributeRef
	 *     Or returns LocalAttributeRef
	 *     Or.Or_1_0 returns LocalAttributeRef
	 *     And returns LocalAttributeRef
	 *     And.And_1_0 returns LocalAttributeRef
	 *     Equality returns LocalAttributeRef
	 *     Equality.Equality_1_0 returns LocalAttributeRef
	 *     Comparison returns LocalAttributeRef
	 *     Comparison.Comparison_1_0 returns LocalAttributeRef
	 *     PlusOrMinus returns LocalAttributeRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns LocalAttributeRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns LocalAttributeRef
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns LocalAttributeRef
	 *     MulOrDiv returns LocalAttributeRef
	 *     MulOrDiv.MulOrDiv_1_0 returns LocalAttributeRef
	 *     Primary returns LocalAttributeRef
	 *     ContainmentExpr returns LocalAttributeRef
	 *     ContainmentExpr.ContainmentExpression_1_0 returns LocalAttributeRef
	 *     AtomicOrExpr returns LocalAttributeRef
	 *     Atomic returns LocalAttributeRef
	 *     Atomic.TupleGet_3_1_1 returns LocalAttributeRef
	 *     AtomicIndexable returns LocalAttributeRef
	 *
	 * Constraint:
	 *     attribute=ID
	 */
	protected void sequence_AtomicIndexable(ISerializationContext context, LocalAttributeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.LOCAL_ATTRIBUTE_REF__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.LOCAL_ATTRIBUTE_REF__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicIndexableAccess().getAttributeIDTerminalRuleCall_3_3_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LocalVarRef
	 *     Or returns LocalVarRef
	 *     Or.Or_1_0 returns LocalVarRef
	 *     And returns LocalVarRef
	 *     And.And_1_0 returns LocalVarRef
	 *     Equality returns LocalVarRef
	 *     Equality.Equality_1_0 returns LocalVarRef
	 *     Comparison returns LocalVarRef
	 *     Comparison.Comparison_1_0 returns LocalVarRef
	 *     PlusOrMinus returns LocalVarRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns LocalVarRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns LocalVarRef
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns LocalVarRef
	 *     MulOrDiv returns LocalVarRef
	 *     MulOrDiv.MulOrDiv_1_0 returns LocalVarRef
	 *     Primary returns LocalVarRef
	 *     ContainmentExpr returns LocalVarRef
	 *     ContainmentExpr.ContainmentExpression_1_0 returns LocalVarRef
	 *     AtomicOrExpr returns LocalVarRef
	 *     Atomic returns LocalVarRef
	 *     Atomic.TupleGet_3_1_1 returns LocalVarRef
	 *     AtomicIndexable returns LocalVarRef
	 *
	 * Constraint:
	 *     ref=[LRef|ID]
	 */
	protected void sequence_AtomicIndexable(ISerializationContext context, LocalVarRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.LOCAL_VAR_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.LOCAL_VAR_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicIndexableAccess().getRefLRefIDTerminalRuleCall_2_1_0_1(), semanticObject.eGet(GoatComponentsPackage.Literals.LOCAL_VAR_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TupleConstant
	 *     Or returns TupleConstant
	 *     Or.Or_1_0 returns TupleConstant
	 *     And returns TupleConstant
	 *     And.And_1_0 returns TupleConstant
	 *     Equality returns TupleConstant
	 *     Equality.Equality_1_0 returns TupleConstant
	 *     Comparison returns TupleConstant
	 *     Comparison.Comparison_1_0 returns TupleConstant
	 *     PlusOrMinus returns TupleConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns TupleConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns TupleConstant
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns TupleConstant
	 *     MulOrDiv returns TupleConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns TupleConstant
	 *     Primary returns TupleConstant
	 *     ContainmentExpr returns TupleConstant
	 *     ContainmentExpr.ContainmentExpression_1_0 returns TupleConstant
	 *     AtomicOrExpr returns TupleConstant
	 *     Atomic returns TupleConstant
	 *     Atomic.TupleGet_3_1_1 returns TupleConstant
	 *     AtomicIndexable returns TupleConstant
	 *
	 * Constraint:
	 *     (elem+=Expression elem+=Expression*)?
	 */
	protected void sequence_AtomicIndexable(ISerializationContext context, TupleConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TupleLength
	 *     Or returns TupleLength
	 *     Or.Or_1_0 returns TupleLength
	 *     And returns TupleLength
	 *     And.And_1_0 returns TupleLength
	 *     Equality returns TupleLength
	 *     Equality.Equality_1_0 returns TupleLength
	 *     Comparison returns TupleLength
	 *     Comparison.Comparison_1_0 returns TupleLength
	 *     PlusOrMinus returns TupleLength
	 *     PlusOrMinus.Plus_1_0_0_0 returns TupleLength
	 *     PlusOrMinus.Minus_1_0_1_0 returns TupleLength
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns TupleLength
	 *     MulOrDiv returns TupleLength
	 *     MulOrDiv.MulOrDiv_1_0 returns TupleLength
	 *     Primary returns TupleLength
	 *     ContainmentExpr returns TupleLength
	 *     ContainmentExpr.ContainmentExpression_1_0 returns TupleLength
	 *     AtomicOrExpr returns TupleLength
	 *     Atomic returns TupleLength
	 *     Atomic.TupleGet_3_1_1 returns TupleLength
	 *     AtomicIndexable returns TupleLength
	 *
	 * Constraint:
	 *     elem=Atomic
	 */
	protected void sequence_AtomicIndexable(ISerializationContext context, TupleLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.TUPLE_LENGTH__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.TUPLE_LENGTH__ELEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicIndexableAccess().getElemAtomicParserRuleCall_1_3_0(), semanticObject.getElem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparison_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     ContainmentExpr returns BoolConstant
	 *     ContainmentExpr.ContainmentExpression_1_0 returns BoolConstant
	 *     AtomicOrExpr returns BoolConstant
	 *     Atomic returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparison_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     ContainmentExpr returns IntConstant
	 *     ContainmentExpr.ContainmentExpression_1_0 returns IntConstant
	 *     AtomicOrExpr returns IntConstant
	 *     Atomic returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringConstant
	 *     Or returns StringConstant
	 *     Or.Or_1_0 returns StringConstant
	 *     And returns StringConstant
	 *     And.And_1_0 returns StringConstant
	 *     Equality returns StringConstant
	 *     Equality.Equality_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.Comparison_1_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns StringConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns StringConstant
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns StringConstant
	 *     Primary returns StringConstant
	 *     ContainmentExpr returns StringConstant
	 *     ContainmentExpr.ContainmentExpression_1_0 returns StringConstant
	 *     AtomicOrExpr returns StringConstant
	 *     Atomic returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TupleGet
	 *     Or returns TupleGet
	 *     Or.Or_1_0 returns TupleGet
	 *     And returns TupleGet
	 *     And.And_1_0 returns TupleGet
	 *     Equality returns TupleGet
	 *     Equality.Equality_1_0 returns TupleGet
	 *     Comparison returns TupleGet
	 *     Comparison.Comparison_1_0 returns TupleGet
	 *     PlusOrMinus returns TupleGet
	 *     PlusOrMinus.Plus_1_0_0_0 returns TupleGet
	 *     PlusOrMinus.Minus_1_0_1_0 returns TupleGet
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns TupleGet
	 *     MulOrDiv returns TupleGet
	 *     MulOrDiv.MulOrDiv_1_0 returns TupleGet
	 *     Primary returns TupleGet
	 *     ContainmentExpr returns TupleGet
	 *     ContainmentExpr.ContainmentExpression_1_0 returns TupleGet
	 *     AtomicOrExpr returns TupleGet
	 *     Atomic returns TupleGet
	 *
	 * Constraint:
	 *     (elem=Atomic_TupleGet_3_1_1 idx=Expression)
	 */
	protected void sequence_Atomic(ISerializationContext context, TupleGet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.TUPLE_GET__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.TUPLE_GET__ELEM));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.TUPLE_GET__IDX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.TUPLE_GET__IDX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getTupleGetElemAction_3_1_1(), semanticObject.getElem());
		feeder.accept(grammarAccess.getAtomicAccess().getIdxExpressionParserRuleCall_3_1_2_0(), semanticObject.getIdx());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     PlusOrMinus returns Comparison
	 *     PlusOrMinus.Plus_1_0_0_0 returns Comparison
	 *     PlusOrMinus.Minus_1_0_1_0 returns Comparison
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns Comparison
	 *     MulOrDiv returns Comparison
	 *     MulOrDiv.MulOrDiv_1_0 returns Comparison
	 *     Primary returns Comparison
	 *     ContainmentExpr returns Comparison
	 *     ContainmentExpr.ContainmentExpression_1_0 returns Comparison
	 *     AtomicOrExpr returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='>=' | op='<=' | op='>' | op='<') right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentDefinition returns ComponentDefinition
	 *
	 * Constraint:
	 *     (((envref=[EnvironmentDefinition|ID] (envargs+=EnvInitOrArg envargs+=EnvInitOrArg*)?) | env=Environment) (block=PDPBlock | block=ProcessBlock))
	 */
	protected void sequence_ComponentDefinition(ISerializationContext context, ComponentDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ContainmentExpression
	 *     Or returns ContainmentExpression
	 *     Or.Or_1_0 returns ContainmentExpression
	 *     And returns ContainmentExpression
	 *     And.And_1_0 returns ContainmentExpression
	 *     Equality returns ContainmentExpression
	 *     Equality.Equality_1_0 returns ContainmentExpression
	 *     Comparison returns ContainmentExpression
	 *     Comparison.Comparison_1_0 returns ContainmentExpression
	 *     PlusOrMinus returns ContainmentExpression
	 *     PlusOrMinus.Plus_1_0_0_0 returns ContainmentExpression
	 *     PlusOrMinus.Minus_1_0_1_0 returns ContainmentExpression
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns ContainmentExpression
	 *     MulOrDiv returns ContainmentExpression
	 *     MulOrDiv.MulOrDiv_1_0 returns ContainmentExpression
	 *     Primary returns ContainmentExpression
	 *     ContainmentExpr returns ContainmentExpression
	 *     ContainmentExpr.ContainmentExpression_1_0 returns ContainmentExpression
	 *     AtomicOrExpr returns ContainmentExpression
	 *
	 * Constraint:
	 *     (elem=ContainmentExpr_ContainmentExpression_1_0 tuple=AtomicOrExpr)
	 */
	protected void sequence_ContainmentExpr(ISerializationContext context, ContainmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__ELEM));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__TUPLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__TUPLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContainmentExprAccess().getContainmentExpressionElemAction_1_0(), semanticObject.getElem());
		feeder.accept(grammarAccess.getContainmentExprAccess().getTupleAtomicOrExprParserRuleCall_1_2_0(), semanticObject.getTuple());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EmptyProcessBlock returns ProcessBlock
	 *
	 * Constraint:
	 *     {ProcessBlock}
	 */
	protected void sequence_EmptyProcessBlock(ISerializationContext context, ProcessBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnvInitOrArg returns EnvironmentArg
	 *
	 * Constraint:
	 *     arg=[EnvParam|ID]
	 */
	protected void sequence_EnvInitOrArg(ISerializationContext context, EnvironmentArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.ENVIRONMENT_ARG__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.ENVIRONMENT_ARG__ARG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvInitOrArgAccess().getArgEnvParamIDTerminalRuleCall_1_1_0_1(), semanticObject.eGet(GoatComponentsPackage.Literals.ENVIRONMENT_ARG__ARG, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvInitValue returns BoolConstant
	 *     EnvInitOrArg returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_EnvInitValue(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnvInitValue returns IntConstant
	 *     EnvInitOrArg returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_EnvInitValue(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvInitValueAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvInitValue returns NegativeIntConstant
	 *     EnvInitOrArg returns NegativeIntConstant
	 *
	 * Constraint:
	 *     negvalue=INT
	 */
	protected void sequence_EnvInitValue(ISerializationContext context, NegativeIntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.NEGATIVE_INT_CONSTANT__NEGVALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.NEGATIVE_INT_CONSTANT__NEGVALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvInitValueAccess().getNegvalueINTTerminalRuleCall_0_2_0(), semanticObject.getNegvalue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvInitValue returns StringConstant
	 *     EnvInitOrArg returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_EnvInitValue(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvInitValueAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvInitValue returns TupleConstant
	 *     EnvInitOrArg returns TupleConstant
	 *
	 * Constraint:
	 *     (elem+=EnvInitValue elem+=EnvInitValue*)?
	 */
	protected void sequence_EnvInitValue(ISerializationContext context, TupleConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnvParam returns EnvParam
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnvParam(ISerializationContext context, EnvParam semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.ENV_PARAM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.ENV_PARAM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvParamAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentDefinition returns EnvironmentDefinition
	 *
	 * Constraint:
	 *     (name=ID (envParams+=EnvParam envParams+=EnvParam*)? env=Environment)
	 */
	protected void sequence_EnvironmentDefinition(ISerializationContext context, EnvironmentDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     (attrs+=ID vals+=EnvInitOrArg (attrs+=ID vals+=EnvInitOrArg)*)?
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     PlusOrMinus returns Equality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Equality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Equality
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns Equality
	 *     MulOrDiv returns Equality
	 *     MulOrDiv.MulOrDiv_1_0 returns Equality
	 *     Primary returns Equality
	 *     ContainmentExpr returns Equality
	 *     ContainmentExpr.ContainmentExpression_1_0 returns Equality
	 *     AtomicOrExpr returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncBlock returns FuncBlock
	 *
	 * Constraint:
	 *     statements+=FuncStatement*
	 */
	protected void sequence_FuncBlock(ISerializationContext context, FuncBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncDefinition returns FuncDefinition
	 *
	 * Constraint:
	 *     (type=TYPE name=ID (params+=FuncParam params+=FuncParam*)? blk=FuncBlock)
	 */
	protected void sequence_FuncDefinition(ISerializationContext context, FuncDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncStatement returns FuncIfElse
	 *     FuncIfElse returns FuncIfElse
	 *
	 * Constraint:
	 *     (test+=Expression then+=FuncBlock (test+=Expression then+=FuncBlock)* elseBranch=FuncBlock?)
	 */
	protected void sequence_FuncIfElse(ISerializationContext context, FuncIfElse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LRef returns FuncParam
	 *     FuncParam returns FuncParam
	 *
	 * Constraint:
	 *     (type=TYPE name=ID)
	 */
	protected void sequence_FuncParam(ISerializationContext context, FuncParam semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_PARAM__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_PARAM__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.LREF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.LREF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncParamAccess().getTypeTYPETerminalRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFuncParamAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncStatement returns FuncReturn
	 *     FuncReturn returns FuncReturn
	 *
	 * Constraint:
	 *     val=Expression
	 */
	protected void sequence_FuncReturn(ISerializationContext context, FuncReturn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_RETURN__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_RETURN__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncReturnAccess().getValExpressionParserRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncStatement returns FuncVarAppend
	 *     FuncVarAppend returns FuncVarAppend
	 *
	 * Constraint:
	 *     (var=[FuncVarDeclaration|ID] item=Expression)
	 */
	protected void sequence_FuncVarAppend(ISerializationContext context, FuncVarAppend semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_APPEND__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_APPEND__VAR));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_APPEND__ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_APPEND__ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncVarAppendAccess().getVarFuncVarDeclarationIDTerminalRuleCall_0_0_1(), semanticObject.eGet(GoatComponentsPackage.Literals.FUNC_VAR_APPEND__VAR, false));
		feeder.accept(grammarAccess.getFuncVarAppendAccess().getItemExpressionParserRuleCall_4_0(), semanticObject.getItem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncStatement returns FuncVarAssign
	 *     FuncVarAssign returns FuncVarAssign
	 *
	 * Constraint:
	 *     (var=[FuncVarDeclaration|ID] idx=Expression? val=Expression)
	 */
	protected void sequence_FuncVarAssign(ISerializationContext context, FuncVarAssign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LRef returns FuncVarDeclaration
	 *     FuncStatement returns FuncVarDeclaration
	 *     FuncVarDeclaration returns FuncVarDeclaration
	 *
	 * Constraint:
	 *     (name=ID val=Expression)
	 */
	protected void sequence_FuncVarDeclaration(ISerializationContext context, FuncVarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.LREF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.LREF__NAME));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_DECLARATION__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_DECLARATION__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncVarDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFuncVarDeclarationAccess().getValExpressionParserRuleCall_3_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncStatement returns FuncVarPop
	 *     FuncVarPop returns FuncVarPop
	 *
	 * Constraint:
	 *     var=[FuncVarDeclaration|ID]
	 */
	protected void sequence_FuncVarPop(ISerializationContext context, FuncVarPop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_POP__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_POP__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncVarPopAccess().getVarFuncVarDeclarationIDTerminalRuleCall_0_0_1(), semanticObject.eGet(GoatComponentsPackage.Literals.FUNC_VAR_POP__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncStatement returns FuncWhile
	 *     FuncWhile returns FuncWhile
	 *
	 * Constraint:
	 *     (cond=Expression cycle=FuncBlock)
	 */
	protected void sequence_FuncWhile(ISerializationContext context, FuncWhile semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_WHILE__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_WHILE__COND));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_WHILE__CYCLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_WHILE__CYCLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncWhileAccess().getCondExpressionParserRuleCall_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getFuncWhileAccess().getCycleFuncBlockParserRuleCall_4_0(), semanticObject.getCycle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         infrastructure=[Infrastructure|ID] 
	 *         (processes+=ProcessDefinition | components+=ComponentDefinition | functions+=FuncDefinition | environments+=EnvironmentDefinition)*
	 *     )
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulOrDiv
	 *     Or returns MulOrDiv
	 *     Or.Or_1_0 returns MulOrDiv
	 *     And returns MulOrDiv
	 *     And.And_1_0 returns MulOrDiv
	 *     Equality returns MulOrDiv
	 *     Equality.Equality_1_0 returns MulOrDiv
	 *     Comparison returns MulOrDiv
	 *     Comparison.Comparison_1_0 returns MulOrDiv
	 *     PlusOrMinus returns MulOrDiv
	 *     PlusOrMinus.Plus_1_0_0_0 returns MulOrDiv
	 *     PlusOrMinus.Minus_1_0_1_0 returns MulOrDiv
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns MulOrDiv
	 *     MulOrDiv returns MulOrDiv
	 *     MulOrDiv.MulOrDiv_1_0 returns MulOrDiv
	 *     Primary returns MulOrDiv
	 *     ContainmentExpr returns MulOrDiv
	 *     ContainmentExpr.ContainmentExpression_1_0 returns MulOrDiv
	 *     AtomicOrExpr returns MulOrDiv
	 *
	 * Constraint:
	 *     (left=MulOrDiv_MulOrDiv_1_0 (op='*' | op='/' | op='%') right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, MulOrDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OCE returns ContainmentExpression
	 *
	 * Constraint:
	 *     (elem=OutAtomicOrRec tuple=OutAtomicOrRec)
	 */
	protected void sequence_OCE(ISerializationContext context, ContainmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__ELEM));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__TUPLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__TUPLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOCEAccess().getElemOutAtomicOrRecParserRuleCall_1_0(), semanticObject.getElem());
		feeder.accept(grammarAccess.getOCEAccess().getTupleOutAtomicOrRecParserRuleCall_3_0(), semanticObject.getTuple());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     PlusOrMinus returns Or
	 *     PlusOrMinus.Plus_1_0_0_0 returns Or
	 *     PlusOrMinus.Minus_1_0_1_0 returns Or
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns Or
	 *     MulOrDiv returns Or
	 *     MulOrDiv.MulOrDiv_1_0 returns Or
	 *     Primary returns Or
	 *     ContainmentExpr returns Or
	 *     ContainmentExpr.ContainmentExpression_1_0 returns Or
	 *     AtomicOrExpr returns Or
	 *
	 * Constraint:
	 *     (sub+=Or_Or_1_0 sub+=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputPredicate returns And
	 *     OutOr returns And
	 *     OutOr.Or_1_0 returns And
	 *     OutAnd returns And
	 *     OutAnd.And_1_0 returns And
	 *     OutEqualityComparison returns And
	 *     OutPrimary returns And
	 *
	 * Constraint:
	 *     (sub+=OutAnd_And_1_0 sub+=OutEqualityComparison)
	 */
	protected void sequence_OutAnd(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutEqualityComparison.OutEqualityComparison_1_1_0_0 returns ComponentAttributeRef
	 *     OutEqualityComparison.ContainmentExpression_1_1_1_0 returns ComponentAttributeRef
	 *     OutAtomicOrRec returns ComponentAttributeRef
	 *     OutAtomic returns ComponentAttributeRef
	 *     OutAtomic.TupleGet_3_1_1 returns ComponentAttributeRef
	 *     OutAtomicIndexable returns ComponentAttributeRef
	 *
	 * Constraint:
	 *     attribute=ID
	 */
	protected void sequence_OutAtomicIndexable(ISerializationContext context, ComponentAttributeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.COMPONENT_ATTRIBUTE_REF__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.COMPONENT_ATTRIBUTE_REF__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutAtomicIndexableAccess().getAttributeIDTerminalRuleCall_4_3_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutEqualityComparison.OutEqualityComparison_1_1_0_0 returns FunctionCall
	 *     OutEqualityComparison.ContainmentExpression_1_1_1_0 returns FunctionCall
	 *     OutAtomicOrRec returns FunctionCall
	 *     OutAtomic returns FunctionCall
	 *     OutAtomic.TupleGet_3_1_1 returns FunctionCall
	 *     OutAtomicIndexable returns FunctionCall
	 *
	 * Constraint:
	 *     (function=[FuncDefinition|ID] (params+=OutAtomic params+=OutAtomic*)?)
	 */
	protected void sequence_OutAtomicIndexable(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutEqualityComparison.OutEqualityComparison_1_1_0_0 returns LocalAttributeRef
	 *     OutEqualityComparison.ContainmentExpression_1_1_1_0 returns LocalAttributeRef
	 *     OutAtomicOrRec returns LocalAttributeRef
	 *     OutAtomic returns LocalAttributeRef
	 *     OutAtomic.TupleGet_3_1_1 returns LocalAttributeRef
	 *     OutAtomicIndexable returns LocalAttributeRef
	 *
	 * Constraint:
	 *     attribute=ID
	 */
	protected void sequence_OutAtomicIndexable(ISerializationContext context, LocalAttributeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.LOCAL_ATTRIBUTE_REF__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.LOCAL_ATTRIBUTE_REF__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutAtomicIndexableAccess().getAttributeIDTerminalRuleCall_3_3_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutEqualityComparison.OutEqualityComparison_1_1_0_0 returns TupleConstant
	 *     OutEqualityComparison.ContainmentExpression_1_1_1_0 returns TupleConstant
	 *     OutAtomicOrRec returns TupleConstant
	 *     OutAtomic returns TupleConstant
	 *     OutAtomic.TupleGet_3_1_1 returns TupleConstant
	 *     OutAtomicIndexable returns TupleConstant
	 *
	 * Constraint:
	 *     (elem+=OutAtomic elem+=OutAtomic*)?
	 */
	protected void sequence_OutAtomicIndexable(ISerializationContext context, TupleConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutEqualityComparison.OutEqualityComparison_1_1_0_0 returns TupleLength
	 *     OutEqualityComparison.ContainmentExpression_1_1_1_0 returns TupleLength
	 *     OutAtomicOrRec returns TupleLength
	 *     OutAtomic returns TupleLength
	 *     OutAtomic.TupleGet_3_1_1 returns TupleLength
	 *     OutAtomicIndexable returns TupleLength
	 *
	 * Constraint:
	 *     elem=OutAtomic
	 */
	protected void sequence_OutAtomicIndexable(ISerializationContext context, TupleLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.TUPLE_LENGTH__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.TUPLE_LENGTH__ELEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutAtomicIndexableAccess().getElemOutAtomicParserRuleCall_1_3_0(), semanticObject.getElem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutEqualityComparison.OutEqualityComparison_1_1_0_0 returns RecAttributeRef
	 *     OutEqualityComparison.ContainmentExpression_1_1_1_0 returns RecAttributeRef
	 *     OutAtomicOrRec returns RecAttributeRef
	 *
	 * Constraint:
	 *     attribute=ID
	 */
	protected void sequence_OutAtomicOrRec(ISerializationContext context, RecAttributeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.REC_ATTRIBUTE_REF__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.REC_ATTRIBUTE_REF__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutAtomicOrRecAccess().getAttributeIDTerminalRuleCall_0_3_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutEqualityComparison.OutEqualityComparison_1_1_0_0 returns BoolConstant
	 *     OutEqualityComparison.ContainmentExpression_1_1_1_0 returns BoolConstant
	 *     OutAtomicOrRec returns BoolConstant
	 *     OutAtomic returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_OutAtomic(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutEqualityComparison.OutEqualityComparison_1_1_0_0 returns IntConstant
	 *     OutEqualityComparison.ContainmentExpression_1_1_1_0 returns IntConstant
	 *     OutAtomicOrRec returns IntConstant
	 *     OutAtomic returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_OutAtomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutEqualityComparison.OutEqualityComparison_1_1_0_0 returns StringConstant
	 *     OutEqualityComparison.ContainmentExpression_1_1_1_0 returns StringConstant
	 *     OutAtomicOrRec returns StringConstant
	 *     OutAtomic returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_OutAtomic(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutAtomicAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutEqualityComparison.OutEqualityComparison_1_1_0_0 returns TupleGet
	 *     OutEqualityComparison.ContainmentExpression_1_1_1_0 returns TupleGet
	 *     OutAtomicOrRec returns TupleGet
	 *     OutAtomic returns TupleGet
	 *
	 * Constraint:
	 *     (elem=OutAtomic_TupleGet_3_1_1 idx=OutAtomic)
	 */
	protected void sequence_OutAtomic(ISerializationContext context, TupleGet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.TUPLE_GET__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.TUPLE_GET__ELEM));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.TUPLE_GET__IDX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.TUPLE_GET__IDX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutAtomicAccess().getTupleGetElemAction_3_1_1(), semanticObject.getElem());
		feeder.accept(grammarAccess.getOutAtomicAccess().getIdxOutAtomicParserRuleCall_3_1_2_0(), semanticObject.getIdx());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputPredicate returns ContainmentExpression
	 *     OutOr returns ContainmentExpression
	 *     OutOr.Or_1_0 returns ContainmentExpression
	 *     OutAnd returns ContainmentExpression
	 *     OutAnd.And_1_0 returns ContainmentExpression
	 *     OutEqualityComparison returns ContainmentExpression
	 *     OutPrimary returns ContainmentExpression
	 *
	 * Constraint:
	 *     (elem=OutEqualityComparison_ContainmentExpression_1_1_1_0 tuple=OutAtomicOrRec)
	 */
	protected void sequence_OutEqualityComparison(ISerializationContext context, ContainmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__ELEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__ELEM));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__TUPLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.CONTAINMENT_EXPRESSION__TUPLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutEqualityComparisonAccess().getContainmentExpressionElemAction_1_1_1_0(), semanticObject.getElem());
		feeder.accept(grammarAccess.getOutEqualityComparisonAccess().getTupleOutAtomicOrRecParserRuleCall_1_1_1_2_0(), semanticObject.getTuple());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputPredicate returns OutEqualityComparison
	 *     OutOr returns OutEqualityComparison
	 *     OutOr.Or_1_0 returns OutEqualityComparison
	 *     OutAnd returns OutEqualityComparison
	 *     OutAnd.And_1_0 returns OutEqualityComparison
	 *     OutEqualityComparison returns OutEqualityComparison
	 *     OutPrimary returns OutEqualityComparison
	 *
	 * Constraint:
	 *     (
	 *         left=OutEqualityComparison_OutEqualityComparison_1_1_0_0 
	 *         (
	 *             op='==' | 
	 *             op='!=' | 
	 *             op='>=' | 
	 *             op='<=' | 
	 *             op='>' | 
	 *             op='<'
	 *         ) 
	 *         right=OutAtomicOrRec
	 *     )
	 */
	protected void sequence_OutEqualityComparison(ISerializationContext context, OutEqualityComparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputPredicate returns Or
	 *     OutOr returns Or
	 *     OutOr.Or_1_0 returns Or
	 *     OutAnd returns Or
	 *     OutAnd.And_1_0 returns Or
	 *     OutEqualityComparison returns Or
	 *     OutPrimary returns Or
	 *
	 * Constraint:
	 *     (sub+=OutOr_Or_1_0 sub+=OutAnd)
	 */
	protected void sequence_OutOr(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputPredicate returns BoolConstant
	 *     OutOr returns BoolConstant
	 *     OutOr.Or_1_0 returns BoolConstant
	 *     OutAnd returns BoolConstant
	 *     OutAnd.And_1_0 returns BoolConstant
	 *     OutEqualityComparison returns BoolConstant
	 *     OutPrimary returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_OutPrimary(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputPredicate returns Not
	 *     OutOr returns Not
	 *     OutOr.Or_1_0 returns Not
	 *     OutAnd returns Not
	 *     OutAnd.And_1_0 returns Not
	 *     OutEqualityComparison returns Not
	 *     OutPrimary returns Not
	 *
	 * Constraint:
	 *     (expression=OutPrimary | expression=OCE)
	 */
	protected void sequence_OutPrimary(ISerializationContext context, Not semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PDPBlock returns ProcessBlock
	 *
	 * Constraint:
	 *     (statements+=PDPSpawn* statements+=PDPCall)
	 */
	protected void sequence_PDPBlock(ISerializationContext context, ProcessBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PDPCall returns ProcessCall
	 *
	 * Constraint:
	 *     proc=[ProcessDefinition|ID]
	 */
	protected void sequence_PDPCall(ISerializationContext context, ProcessCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.PROCESS_CALL__PROC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.PROCESS_CALL__PROC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPDPCallAccess().getProcProcessDefinitionIDTerminalRuleCall_0_1(), semanticObject.eGet(GoatComponentsPackage.Literals.PROCESS_CALL__PROC, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PDPSpawn returns ProcessSpawn
	 *
	 * Constraint:
	 *     proc=[ProcessDefinition|ID]
	 */
	protected void sequence_PDPSpawn(ISerializationContext context, ProcessSpawn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.PROCESS_SPAWN__PROC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.PROCESS_SPAWN__PROC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPDPSpawnAccess().getProcProcessDefinitionIDTerminalRuleCall_0_1(), semanticObject.eGet(GoatComponentsPackage.Literals.PROCESS_SPAWN__PROC, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PTBThen returns ProcessBlock
	 *
	 * Constraint:
	 *     statements+=ProcessStatement*
	 */
	protected void sequence_PTBThen(ISerializationContext context, ProcessBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Concatenate
	 *     Or returns Concatenate
	 *     Or.Or_1_0 returns Concatenate
	 *     And returns Concatenate
	 *     And.And_1_0 returns Concatenate
	 *     Equality returns Concatenate
	 *     Equality.Equality_1_0 returns Concatenate
	 *     Comparison returns Concatenate
	 *     Comparison.Comparison_1_0 returns Concatenate
	 *     PlusOrMinus returns Concatenate
	 *     PlusOrMinus.Plus_1_0_0_0 returns Concatenate
	 *     PlusOrMinus.Minus_1_0_1_0 returns Concatenate
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns Concatenate
	 *     MulOrDiv returns Concatenate
	 *     MulOrDiv.MulOrDiv_1_0 returns Concatenate
	 *     Primary returns Concatenate
	 *     ContainmentExpr returns Concatenate
	 *     ContainmentExpr.ContainmentExpression_1_0 returns Concatenate
	 *     AtomicOrExpr returns Concatenate
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Concatenate_1_0_2_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Concatenate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.CONCATENATE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.CONCATENATE__LEFT));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.CONCATENATE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.CONCATENATE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getConcatenateLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns Minus
	 *     MulOrDiv returns Minus
	 *     MulOrDiv.MulOrDiv_1_0 returns Minus
	 *     Primary returns Minus
	 *     ContainmentExpr returns Minus
	 *     ContainmentExpr.ContainmentExpression_1_0 returns Minus
	 *     AtomicOrExpr returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns Plus
	 *     MulOrDiv returns Plus
	 *     MulOrDiv.MulOrDiv_1_0 returns Plus
	 *     Primary returns Plus
	 *     ContainmentExpr returns Plus
	 *     ContainmentExpr.ContainmentExpression_1_0 returns Plus
	 *     AtomicOrExpr returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.MulOrDiv_1_0 returns Not
	 *     Primary returns Not
	 *     ContainmentExpr returns Not
	 *     ContainmentExpr.ContainmentExpression_1_0 returns Not
	 *     AtomicOrExpr returns Not
	 *
	 * Constraint:
	 *     expression=ContainmentExpr
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionContainmentExprParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryMinus
	 *     Or returns UnaryMinus
	 *     Or.Or_1_0 returns UnaryMinus
	 *     And returns UnaryMinus
	 *     And.And_1_0 returns UnaryMinus
	 *     Equality returns UnaryMinus
	 *     Equality.Equality_1_0 returns UnaryMinus
	 *     Comparison returns UnaryMinus
	 *     Comparison.Comparison_1_0 returns UnaryMinus
	 *     PlusOrMinus returns UnaryMinus
	 *     PlusOrMinus.Plus_1_0_0_0 returns UnaryMinus
	 *     PlusOrMinus.Minus_1_0_1_0 returns UnaryMinus
	 *     PlusOrMinus.Concatenate_1_0_2_0 returns UnaryMinus
	 *     MulOrDiv returns UnaryMinus
	 *     MulOrDiv.MulOrDiv_1_0 returns UnaryMinus
	 *     Primary returns UnaryMinus
	 *     ContainmentExpr returns UnaryMinus
	 *     ContainmentExpr.ContainmentExpression_1_0 returns UnaryMinus
	 *     AtomicOrExpr returns UnaryMinus
	 *
	 * Constraint:
	 *     expression=ContainmentExpr
	 */
	protected void sequence_Primary(ISerializationContext context, UnaryMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.UNARY_MINUS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.UNARY_MINUS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionContainmentExprParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrintAllStatement returns PrintAllStatement
	 *
	 * Constraint:
	 *     {PrintAllStatement}
	 */
	protected void sequence_PrintAllStatement(ISerializationContext context, PrintAllStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrintStatement returns PrintFormattedStatement
	 *     PrintFormattedStatement returns PrintFormattedStatement
	 *
	 * Constraint:
	 *     toPrint=STRING
	 */
	protected void sequence_PrintFormattedStatement(ISerializationContext context, PrintFormattedStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.PRINT_FORMATTED_STATEMENT__TO_PRINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.PRINT_FORMATTED_STATEMENT__TO_PRINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintFormattedStatementAccess().getToPrintSTRINGTerminalRuleCall_2_0(), semanticObject.getToPrint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcessBlock returns ProcessBlock
	 *
	 * Constraint:
	 *     statements+=ProcessStatement*
	 */
	protected void sequence_ProcessBlock(ISerializationContext context, ProcessBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatement returns ProcessCall
	 *     ProcessCall returns ProcessCall
	 *
	 * Constraint:
	 *     proc=[ProcessDefinition|ID]
	 */
	protected void sequence_ProcessCall(ISerializationContext context, ProcessCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.PROCESS_CALL__PROC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.PROCESS_CALL__PROC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessCallAccess().getProcProcessDefinitionIDTerminalRuleCall_2_0_1(), semanticObject.eGet(GoatComponentsPackage.Literals.PROCESS_CALL__PROC, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcessDefinition returns ProcessDefinition
	 *
	 * Constraint:
	 *     (name=ID (block=PDPBlock | block=ProcessBlock))
	 */
	protected void sequence_ProcessDefinition(ISerializationContext context, ProcessDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatement returns ProcessIf
	 *     ProcessIf returns ProcessIf
	 *
	 * Constraint:
	 *     (
	 *         cond+=Expression 
	 *         (action+=ProcessSend | action+=ProcessReceive | action+=ProcessSet) 
	 *         then+=PTBThen 
	 *         (cond+=Expression? (action+=ProcessSend | action+=ProcessReceive | action+=ProcessSet) then+=PTBThen)*
	 *     )
	 */
	protected void sequence_ProcessIf_ProcessThenBlock(ISerializationContext context, ProcessIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatement returns ProcessLoop
	 *     ProcessLoop returns ProcessLoop
	 *
	 * Constraint:
	 *     block=ProcessBlock
	 */
	protected void sequence_ProcessLoop(ISerializationContext context, ProcessLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.PROCESS_LOOP__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.PROCESS_LOOP__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessLoopAccess().getBlockProcessBlockParserRuleCall_1_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatement returns ProcessReceiveMultiple
	 *     ProcessReceive returns ProcessReceiveMultiple
	 *     ProcessReceiveMultiple returns ProcessReceiveMultiple
	 *
	 * Constraint:
	 *     (cases+=ReceiveCase then+=ProcessBlock)+
	 */
	protected void sequence_ProcessReceiveMultiple(ISerializationContext context, ProcessReceiveMultiple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatement returns ProcessReceiveSingle
	 *     ProcessReceive returns ProcessReceiveSingle
	 *     ProcessReceiveSingle returns ProcessReceiveSingle
	 *
	 * Constraint:
	 *     (cases+=ReceiveCase then+=EmptyProcessBlock)
	 */
	protected void sequence_ProcessReceiveSingle(ISerializationContext context, ProcessReceiveSingle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatement returns ProcessSend
	 *     ProcessSend returns ProcessSend
	 *
	 * Constraint:
	 *     ((msgOutParts+=Expression msgOutParts+=Expression*)? send_pred=OutputPredicate updates=Update print=PrintStatement?)
	 */
	protected void sequence_ProcessSend(ISerializationContext context, ProcessSend semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatement returns ProcessSet
	 *     ProcessSet returns ProcessSet
	 *
	 * Constraint:
	 *     (update=Update print=PrintStatement?)
	 */
	protected void sequence_ProcessSet(ISerializationContext context, ProcessSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatement returns ProcessSpawn
	 *     ProcessSpawn returns ProcessSpawn
	 *
	 * Constraint:
	 *     proc=[ProcessDefinition|ID]
	 */
	protected void sequence_ProcessSpawn(ISerializationContext context, ProcessSpawn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.PROCESS_SPAWN__PROC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.PROCESS_SPAWN__PROC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessSpawnAccess().getProcProcessDefinitionIDTerminalRuleCall_2_0_1(), semanticObject.eGet(GoatComponentsPackage.Literals.PROCESS_SPAWN__PROC, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcessStatement returns ProcessWaitFor
	 *     ProcessWaitFor returns ProcessWaitFor
	 *
	 * Constraint:
	 *     (cond=Expression update=Update print=PrintStatement?)
	 */
	protected void sequence_ProcessWaitFor(ISerializationContext context, ProcessWaitFor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReceiveCase returns ReceiveCase
	 *
	 * Constraint:
	 *     (cond=Expression (msgInParts+=ID msgInParts+=ID*)? updates=Update print=PrintStatement?)
	 */
	protected void sequence_ReceiveCase(ISerializationContext context, ReceiveCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UpdateComponentAttribute returns UpdateComponentAttribute
	 *
	 * Constraint:
	 *     atname=ID
	 */
	protected void sequence_UpdateComponentAttribute(ISerializationContext context, UpdateComponentAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.UPDATE_COMPONENT_ATTRIBUTE__ATNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.UPDATE_COMPONENT_ATTRIBUTE__ATNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateComponentAttributeAccess().getAtnameIDTerminalRuleCall_2_0(), semanticObject.getAtname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UpdateLocalAttribute returns UpdateLocalAttribute
	 *
	 * Constraint:
	 *     atname=ID
	 */
	protected void sequence_UpdateLocalAttribute(ISerializationContext context, UpdateLocalAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.UPDATE_LOCAL_ATTRIBUTE__ATNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.UPDATE_LOCAL_ATTRIBUTE__ATNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateLocalAttributeAccess().getAtnameIDTerminalRuleCall_2_0(), semanticObject.getAtname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Update returns Update
	 *
	 * Constraint:
	 *     (
	 *         (attribute+=UpdateComponentAttribute | attribute+=UpdateLocalAttribute) 
	 *         value+=Expression 
	 *         ((attribute+=UpdateComponentAttribute | attribute+=UpdateLocalAttribute) value+=Expression)*
	 *     )?
	 */
	protected void sequence_Update(ISerializationContext context, Update semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
