/*
 * generated by Xtext 2.12.0
 */
package com.sysma.goat.eclipse_plugin.serializer;

import com.google.inject.Inject;
import com.sysma.goat.eclipse_plugin.goatComponents.And;
import com.sysma.goat.eclipse_plugin.goatComponents.Attribute;
import com.sysma.goat.eclipse_plugin.goatComponents.AttributeValue;
import com.sysma.goat.eclipse_plugin.goatComponents.Awareness;
import com.sysma.goat.eclipse_plugin.goatComponents.CallProcess;
import com.sysma.goat.eclipse_plugin.goatComponents.ComponentDefinition;
import com.sysma.goat.eclipse_plugin.goatComponents.Environment;
import com.sysma.goat.eclipse_plugin.goatComponents.EqualityTest;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncAnd;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncBlock;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncDefinition;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncEqualityTest;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncIfElse;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncImmediate;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncMemoryRef;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncNot;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncParam;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncPredicate;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncReturn;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncString;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncVarAssign;
import com.sysma.goat.eclipse_plugin.goatComponents.FuncVarDeclaration;
import com.sysma.goat.eclipse_plugin.goatComponents.GoStringFunction;
import com.sysma.goat.eclipse_plugin.goatComponents.GoatComponentsPackage;
import com.sysma.goat.eclipse_plugin.goatComponents.IfBranchProcess;
import com.sysma.goat.eclipse_plugin.goatComponents.IfProcesses;
import com.sysma.goat.eclipse_plugin.goatComponents.Immediate;
import com.sysma.goat.eclipse_plugin.goatComponents.ImmediateValue;
import com.sysma.goat.eclipse_plugin.goatComponents.InputProcess;
import com.sysma.goat.eclipse_plugin.goatComponents.InputProcesses;
import com.sysma.goat.eclipse_plugin.goatComponents.InterleavingProcess;
import com.sysma.goat.eclipse_plugin.goatComponents.Model;
import com.sysma.goat.eclipse_plugin.goatComponents.Not;
import com.sysma.goat.eclipse_plugin.goatComponents.OutputProcess;
import com.sysma.goat.eclipse_plugin.goatComponents.Preconditions;
import com.sysma.goat.eclipse_plugin.goatComponents.Predicate;
import com.sysma.goat.eclipse_plugin.goatComponents.ProcessDefinition;
import com.sysma.goat.eclipse_plugin.goatComponents.RecAttribute;
import com.sysma.goat.eclipse_plugin.goatComponents.Update;
import com.sysma.goat.eclipse_plugin.goatComponents.ZeroProcess;
import com.sysma.goat.eclipse_plugin.services.GoatComponentsGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GoatComponentsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GoatComponentsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GoatComponentsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GoatComponentsPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case GoatComponentsPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case GoatComponentsPackage.ATTRIBUTE_VALUE:
				sequence_AttributeValue(context, (AttributeValue) semanticObject); 
				return; 
			case GoatComponentsPackage.AWARENESS:
				sequence_Awareness(context, (Awareness) semanticObject); 
				return; 
			case GoatComponentsPackage.CALL_PROCESS:
				sequence_CallProcess(context, (CallProcess) semanticObject); 
				return; 
			case GoatComponentsPackage.COMPONENT_DEFINITION:
				sequence_ComponentDefinition(context, (ComponentDefinition) semanticObject); 
				return; 
			case GoatComponentsPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case GoatComponentsPackage.EQUALITY_TEST:
				sequence_EqualityTest(context, (EqualityTest) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_AND:
				sequence_FuncAnd(context, (FuncAnd) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_BLOCK:
				sequence_FuncBlock(context, (FuncBlock) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_DEFINITION:
				sequence_FuncDefinition(context, (FuncDefinition) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_EQUALITY_TEST:
				sequence_FuncEqualityTest(context, (FuncEqualityTest) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_IF_ELSE:
				sequence_FuncIfElse(context, (FuncIfElse) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_IMMEDIATE:
				sequence_FuncImmediate(context, (FuncImmediate) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_MEMORY_REF:
				sequence_FuncVal(context, (FuncMemoryRef) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_NOT:
				sequence_FuncNot(context, (FuncNot) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_PARAM:
				sequence_FuncParam(context, (FuncParam) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_PREDICATE:
				sequence_FuncPredicate(context, (FuncPredicate) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_RETURN:
				sequence_FuncReturn(context, (FuncReturn) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_STRING:
				sequence_FuncVal(context, (FuncString) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_VAR_ASSIGN:
				sequence_FuncVarAssign(context, (FuncVarAssign) semanticObject); 
				return; 
			case GoatComponentsPackage.FUNC_VAR_DECLARATION:
				sequence_FuncVarDeclaration(context, (FuncVarDeclaration) semanticObject); 
				return; 
			case GoatComponentsPackage.GO_STRING_FUNCTION:
				sequence_GoStringFunction(context, (GoStringFunction) semanticObject); 
				return; 
			case GoatComponentsPackage.IF_BRANCH_PROCESS:
				sequence_IfBranchProcess(context, (IfBranchProcess) semanticObject); 
				return; 
			case GoatComponentsPackage.IF_PROCESSES:
				sequence_IfProcesses(context, (IfProcesses) semanticObject); 
				return; 
			case GoatComponentsPackage.IMMEDIATE:
				sequence_Immediate(context, (Immediate) semanticObject); 
				return; 
			case GoatComponentsPackage.IMMEDIATE_VALUE:
				sequence_ImmediateValue(context, (ImmediateValue) semanticObject); 
				return; 
			case GoatComponentsPackage.INPUT_PROCESS:
				sequence_InputProcess(context, (InputProcess) semanticObject); 
				return; 
			case GoatComponentsPackage.INPUT_PROCESSES:
				if (rule == grammarAccess.getProcRule()
						|| rule == grammarAccess.getNonDeterminismProcessRule()
						|| rule == grammarAccess.getPredOutputProcessOrInputProcessesRule()
						|| rule == grammarAccess.getNZCProcessRule()
						|| rule == grammarAccess.getNProcessRule()) {
					sequence_InputProcessesPart_PredOutputProcessOrInputProcesses(context, (InputProcesses) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPredOutputProcessOrInputProcessRule()) {
					sequence_PredOutputProcessOrInputProcess(context, (InputProcesses) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.INTERLEAVING_PROCESS:
				sequence_InterleavingProcess(context, (InterleavingProcess) semanticObject); 
				return; 
			case GoatComponentsPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case GoatComponentsPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case GoatComponentsPackage.OUTPUT_PROCESS:
				if (rule == grammarAccess.getPredOutputProcessOrInputProcessRule()) {
					sequence_OutputProcessPart_PredOutputProcessOrInputProcess(context, (OutputProcess) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getProcRule()
						|| rule == grammarAccess.getNonDeterminismProcessRule()
						|| rule == grammarAccess.getPredOutputProcessOrInputProcessesRule()
						|| rule == grammarAccess.getNZCProcessRule()
						|| rule == grammarAccess.getNProcessRule()) {
					sequence_OutputProcessPart_PredOutputProcessOrInputProcesses(context, (OutputProcess) semanticObject); 
					return; 
				}
				else break;
			case GoatComponentsPackage.PRECONDITIONS:
				sequence_Preconditions(context, (Preconditions) semanticObject); 
				return; 
			case GoatComponentsPackage.PREDICATE:
				sequence_Predicate(context, (Predicate) semanticObject); 
				return; 
			case GoatComponentsPackage.PROCESS_DEFINITION:
				sequence_ProcessDefinition(context, (ProcessDefinition) semanticObject); 
				return; 
			case GoatComponentsPackage.REC_ATTRIBUTE:
				sequence_RecAttribute(context, (RecAttribute) semanticObject); 
				return; 
			case GoatComponentsPackage.UPDATE:
				sequence_Update(context, (Update) semanticObject); 
				return; 
			case GoatComponentsPackage.ZERO_PROCESS:
				sequence_ZeroProcess(context, (ZeroProcess) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Predicate returns And
	 *     Predicate.Predicate_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Not returns And
	 *     Term returns And
	 *
	 * Constraint:
	 *     (and+=And_And_1_0 and+=Not)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns AttributeValue
	 *     AttributeValue returns AttributeValue
	 *
	 * Constraint:
	 *     attr=Attribute
	 */
	protected void sequence_AttributeValue(ISerializationContext context, AttributeValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.ATTRIBUTE_VALUE__ATTR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.ATTRIBUTE_VALUE__ATTR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeValueAccess().getAttrAttributeParserRuleCall_1_0(), semanticObject.getAttr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (comp?='this'? ident=ID)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Awareness returns Awareness
	 *
	 * Constraint:
	 *     pred=Predicate
	 */
	protected void sequence_Awareness(ISerializationContext context, Awareness semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.AWARENESS__PRED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.AWARENESS__PRED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAwarenessAccess().getPredPredicateParserRuleCall_1_0(), semanticObject.getPred());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InterleavingProcess.InterleavingProcess_1 returns CallProcess
	 *     NZCProcess returns CallProcess
	 *     CallProcess returns CallProcess
	 *
	 * Constraint:
	 *     (procname=[ProcessDefinition|ID] (params+=Value params+=Value*)?)
	 */
	protected void sequence_CallProcess(ISerializationContext context, CallProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentDefinition returns ComponentDefinition
	 *
	 * Constraint:
	 *     (env=Environment proc=[ProcessDefinition|ID] (params+=STRING params+=STRING*)? address=STRING)
	 */
	protected void sequence_ComponentDefinition(ISerializationContext context, ComponentDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     (attrs+=ID vals+=STRING (attrs+=ID vals+=STRING)*)?
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns EqualityTest
	 *     Predicate.Predicate_1_0 returns EqualityTest
	 *     And returns EqualityTest
	 *     And.And_1_0 returns EqualityTest
	 *     Not returns EqualityTest
	 *     Term returns EqualityTest
	 *     EqualityTest returns EqualityTest
	 *
	 * Constraint:
	 *     (
	 *         (op1=Value | op1=RecAttribute) 
	 *         (
	 *             operand='<' | 
	 *             operand='>' | 
	 *             operand='<=' | 
	 *             operand='>=' | 
	 *             operand='=' | 
	 *             operand='!='
	 *         ) 
	 *         op2=Value
	 *     )
	 */
	protected void sequence_EqualityTest(ISerializationContext context, EqualityTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncPredicate returns FuncAnd
	 *     FuncPredicate.FuncPredicate_1_0 returns FuncAnd
	 *     FuncAnd returns FuncAnd
	 *     FuncAnd.FuncAnd_1_0 returns FuncAnd
	 *     FuncNot returns FuncAnd
	 *     FuncTerm returns FuncAnd
	 *
	 * Constraint:
	 *     (and+=FuncAnd_FuncAnd_1_0 and+=FuncNot)
	 */
	protected void sequence_FuncAnd(ISerializationContext context, FuncAnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncBlock returns FuncBlock
	 *
	 * Constraint:
	 *     statements+=FuncStatement*
	 */
	protected void sequence_FuncBlock(ISerializationContext context, FuncBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncDefinition returns FuncDefinition
	 *
	 * Constraint:
	 *     (name=ID (params+=FuncParam params+=FuncParam*)? blk=FuncBlock)
	 */
	protected void sequence_FuncDefinition(ISerializationContext context, FuncDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncPredicate returns FuncEqualityTest
	 *     FuncPredicate.FuncPredicate_1_0 returns FuncEqualityTest
	 *     FuncAnd returns FuncEqualityTest
	 *     FuncAnd.FuncAnd_1_0 returns FuncEqualityTest
	 *     FuncNot returns FuncEqualityTest
	 *     FuncTerm returns FuncEqualityTest
	 *     FuncEqualityTest returns FuncEqualityTest
	 *
	 * Constraint:
	 *     (
	 *         op1=FuncVal 
	 *         (
	 *             operand='<' | 
	 *             operand='>' | 
	 *             operand='<=' | 
	 *             operand='>=' | 
	 *             operand='=' | 
	 *             operand='!='
	 *         ) 
	 *         op2=FuncVal
	 *     )
	 */
	protected void sequence_FuncEqualityTest(ISerializationContext context, FuncEqualityTest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncStatement returns FuncIfElse
	 *     FuncIfElse returns FuncIfElse
	 *
	 * Constraint:
	 *     (test+=FuncPredicate then+=FuncBlock (test+=FuncPredicate then+=FuncBlock)* elseBranch=FuncBlock?)
	 */
	protected void sequence_FuncIfElse(ISerializationContext context, FuncIfElse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncPredicate returns FuncImmediate
	 *     FuncPredicate.FuncPredicate_1_0 returns FuncImmediate
	 *     FuncAnd returns FuncImmediate
	 *     FuncAnd.FuncAnd_1_0 returns FuncImmediate
	 *     FuncNot returns FuncImmediate
	 *     FuncTerm returns FuncImmediate
	 *     FuncImmediate returns FuncImmediate
	 *
	 * Constraint:
	 *     isTrue?='true'?
	 */
	protected void sequence_FuncImmediate(ISerializationContext context, FuncImmediate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncPredicate returns FuncNot
	 *     FuncPredicate.FuncPredicate_1_0 returns FuncNot
	 *     FuncAnd returns FuncNot
	 *     FuncAnd.FuncAnd_1_0 returns FuncNot
	 *     FuncNot returns FuncNot
	 *     FuncTerm returns FuncNot
	 *
	 * Constraint:
	 *     (neg?='!' term=FuncTerm)
	 */
	protected void sequence_FuncNot(ISerializationContext context, FuncNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_NOT__NEG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_NOT__NEG));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_NOT__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_NOT__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncNotAccess().getNegExclamationMarkKeyword_1_1_0(), semanticObject.isNeg());
		feeder.accept(grammarAccess.getFuncNotAccess().getTermFuncTermParserRuleCall_1_2_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncParam returns FuncParam
	 *     FuncVarParam returns FuncParam
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_FuncParam(ISerializationContext context, FuncParam semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_PARAM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_PARAM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncParamAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncPredicate returns FuncPredicate
	 *     FuncPredicate.FuncPredicate_1_0 returns FuncPredicate
	 *     FuncAnd returns FuncPredicate
	 *     FuncAnd.FuncAnd_1_0 returns FuncPredicate
	 *     FuncNot returns FuncPredicate
	 *     FuncTerm returns FuncPredicate
	 *
	 * Constraint:
	 *     (or+=FuncPredicate_FuncPredicate_1_0 or+=FuncAnd)
	 */
	protected void sequence_FuncPredicate(ISerializationContext context, FuncPredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuncStatement returns FuncReturn
	 *     FuncReturn returns FuncReturn
	 *
	 * Constraint:
	 *     val=FuncVal
	 */
	protected void sequence_FuncReturn(ISerializationContext context, FuncReturn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_RETURN__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_RETURN__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncReturnAccess().getValFuncValParserRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncVal returns FuncMemoryRef
	 *
	 * Constraint:
	 *     ref=[FuncVarParam|ID]
	 */
	protected void sequence_FuncVal(ISerializationContext context, FuncMemoryRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_MEMORY_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_MEMORY_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncValAccess().getRefFuncVarParamIDTerminalRuleCall_1_1_0_1(), semanticObject.eGet(GoatComponentsPackage.Literals.FUNC_MEMORY_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncVal returns FuncString
	 *
	 * Constraint:
	 *     imm=STRING
	 */
	protected void sequence_FuncVal(ISerializationContext context, FuncString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_STRING__IMM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_STRING__IMM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncValAccess().getImmSTRINGTerminalRuleCall_0_1_0(), semanticObject.getImm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncStatement returns FuncVarAssign
	 *     FuncVarAssign returns FuncVarAssign
	 *
	 * Constraint:
	 *     (var=[FuncVarDeclaration|ID] val=FuncVal)
	 */
	protected void sequence_FuncVarAssign(ISerializationContext context, FuncVarAssign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_ASSIGN__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_ASSIGN__VAR));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_ASSIGN__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_ASSIGN__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncVarAssignAccess().getVarFuncVarDeclarationIDTerminalRuleCall_0_0_1(), semanticObject.eGet(GoatComponentsPackage.Literals.FUNC_VAR_ASSIGN__VAR, false));
		feeder.accept(grammarAccess.getFuncVarAssignAccess().getValFuncValParserRuleCall_2_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncStatement returns FuncVarDeclaration
	 *     FuncVarDeclaration returns FuncVarDeclaration
	 *     FuncVarParam returns FuncVarDeclaration
	 *
	 * Constraint:
	 *     (name=ID val=FuncVal)
	 */
	protected void sequence_FuncVarDeclaration(ISerializationContext context, FuncVarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_PARAM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_PARAM__NAME));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_DECLARATION__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.FUNC_VAR_DECLARATION__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncVarDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFuncVarDeclarationAccess().getValFuncValParserRuleCall_3_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns GoStringFunction
	 *     GoStringFunction returns GoStringFunction
	 *
	 * Constraint:
	 *     (funcname=[FuncDefinition|ID] (params+=Value params+=Value*)?)
	 */
	protected void sequence_GoStringFunction(ISerializationContext context, GoStringFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfBranchProcess returns IfBranchProcess
	 *
	 * Constraint:
	 *     (cond=Preconditions then=PredOutputProcessOrInputProcess)
	 */
	protected void sequence_IfBranchProcess(ISerializationContext context, IfBranchProcess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.IF_BRANCH_PROCESS__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.IF_BRANCH_PROCESS__COND));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.IF_BRANCH_PROCESS__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.IF_BRANCH_PROCESS__THEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfBranchProcessAccess().getCondPreconditionsParserRuleCall_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getIfBranchProcessAccess().getThenPredOutputProcessOrInputProcessParserRuleCall_4_0(), semanticObject.getThen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Proc returns IfProcesses
	 *     NonDeterminismProcess returns IfProcesses
	 *     IfProcesses returns IfProcesses
	 *     NZCProcess returns IfProcesses
	 *     NProcess returns IfProcesses
	 *
	 * Constraint:
	 *     (branches+=IfBranchProcess branches+=IfBranchProcess*)
	 */
	protected void sequence_IfProcesses(ISerializationContext context, IfProcesses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns ImmediateValue
	 *     ImmediateValue returns ImmediateValue
	 *
	 * Constraint:
	 *     imm=STRING
	 */
	protected void sequence_ImmediateValue(ISerializationContext context, ImmediateValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.IMMEDIATE_VALUE__IMM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.IMMEDIATE_VALUE__IMM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImmediateValueAccess().getImmSTRINGTerminalRuleCall_1_0(), semanticObject.getImm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns Immediate
	 *     Predicate.Predicate_1_0 returns Immediate
	 *     And returns Immediate
	 *     And.And_1_0 returns Immediate
	 *     Not returns Immediate
	 *     Term returns Immediate
	 *     Immediate returns Immediate
	 *
	 * Constraint:
	 *     isTrue?='true'?
	 */
	protected void sequence_Immediate(ISerializationContext context, Immediate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputProcess returns InputProcess
	 *
	 * Constraint:
	 *     (rec_pred=Predicate (msgInParts+=Attribute msgInParts+=Attribute*)? output=STRING? next=NZCProcess)
	 */
	protected void sequence_InputProcess(ISerializationContext context, InputProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Proc returns InputProcesses
	 *     NonDeterminismProcess returns InputProcesses
	 *     PredOutputProcessOrInputProcesses returns InputProcesses
	 *     NZCProcess returns InputProcesses
	 *     NProcess returns InputProcesses
	 *
	 * Constraint:
	 *     (preconds+=PredOutputProcessOrInputProcesses_InputProcesses_1_1_0 inputs+=InputProcess (preconds+=Preconditions inputs+=InputProcess)*)
	 */
	protected void sequence_InputProcessesPart_PredOutputProcessOrInputProcesses(ISerializationContext context, InputProcesses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Proc returns InterleavingProcess
	 *     InterleavingProcess returns InterleavingProcess
	 *     NonDeterminismProcess returns InterleavingProcess
	 *     NZCProcess returns InterleavingProcess
	 *     NProcess returns InterleavingProcess
	 *
	 * Constraint:
	 *     (subProcs+=InterleavingProcess_InterleavingProcess_1 subProcs+=CallProcess*)
	 */
	protected void sequence_InterleavingProcess(ISerializationContext context, InterleavingProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (processes+=ProcessDefinition | components+=ComponentDefinition | functions+=FuncDefinition)+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns Not
	 *     Predicate.Predicate_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Not returns Not
	 *     Term returns Not
	 *
	 * Constraint:
	 *     (neg?='!' term=Term)
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.NOT__NEG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.NOT__NEG));
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.NOT__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.NOT__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getNegExclamationMarkKeyword_1_1_0(), semanticObject.isNeg());
		feeder.accept(grammarAccess.getNotAccess().getTermTermParserRuleCall_1_2_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PredOutputProcessOrInputProcess returns OutputProcess
	 *
	 * Constraint:
	 *     (
	 *         precond=PredOutputProcessOrInputProcess_OutputProcess_1_0_0 
	 *         (msgOutParts+=Value msgOutParts+=Value*)? 
	 *         send_pred=Predicate 
	 *         output=STRING? 
	 *         msec=INT? 
	 *         next=NZCProcess
	 *     )
	 */
	protected void sequence_OutputProcessPart_PredOutputProcessOrInputProcess(ISerializationContext context, OutputProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Proc returns OutputProcess
	 *     NonDeterminismProcess returns OutputProcess
	 *     PredOutputProcessOrInputProcesses returns OutputProcess
	 *     NZCProcess returns OutputProcess
	 *     NProcess returns OutputProcess
	 *
	 * Constraint:
	 *     (
	 *         precond=PredOutputProcessOrInputProcesses_OutputProcess_1_0_0 
	 *         (msgOutParts+=Value msgOutParts+=Value*)? 
	 *         send_pred=Predicate 
	 *         output=STRING? 
	 *         msec=INT? 
	 *         next=NZCProcess
	 *     )
	 */
	protected void sequence_OutputProcessPart_PredOutputProcessOrInputProcesses(ISerializationContext context, OutputProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Preconditions returns Preconditions
	 *     PredOutputProcessOrInputProcesses.OutputProcess_1_0_0 returns Preconditions
	 *     PredOutputProcessOrInputProcesses.InputProcesses_1_1_0 returns Preconditions
	 *     PredOutputProcessOrInputProcess.OutputProcess_1_0_0 returns Preconditions
	 *     PredOutputProcessOrInputProcess.InputProcesses_1_1_0 returns Preconditions
	 *
	 * Constraint:
	 *     (precond+=Update | precond+=Awareness)*
	 */
	protected void sequence_Preconditions(ISerializationContext context, Preconditions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PredOutputProcessOrInputProcess returns InputProcesses
	 *
	 * Constraint:
	 *     (preconds+=PredOutputProcessOrInputProcess_InputProcesses_1_1_0 inputs+=InputProcess)
	 */
	protected void sequence_PredOutputProcessOrInputProcess(ISerializationContext context, InputProcesses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns Predicate
	 *     Predicate.Predicate_1_0 returns Predicate
	 *     And returns Predicate
	 *     And.And_1_0 returns Predicate
	 *     Not returns Predicate
	 *     Term returns Predicate
	 *
	 * Constraint:
	 *     (or+=Predicate_Predicate_1_0 or+=And)
	 */
	protected void sequence_Predicate(ISerializationContext context, Predicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessDefinition returns ProcessDefinition
	 *
	 * Constraint:
	 *     (name=ID (params+=ID params+=ID*)? proc=Proc)
	 */
	protected void sequence_ProcessDefinition(ISerializationContext context, ProcessDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecAttribute returns RecAttribute
	 *
	 * Constraint:
	 *     ident=ID
	 */
	protected void sequence_RecAttribute(ISerializationContext context, RecAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoatComponentsPackage.Literals.REC_ATTRIBUTE__IDENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoatComponentsPackage.Literals.REC_ATTRIBUTE__IDENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecAttributeAccess().getIdentIDTerminalRuleCall_2_0(), semanticObject.getIdent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Update returns Update
	 *
	 * Constraint:
	 *     (vars+=Attribute vals+=Value (vars+=Attribute vals+=Value)*)
	 */
	protected void sequence_Update(ISerializationContext context, Update semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Proc returns ZeroProcess
	 *     NonDeterminismProcess returns ZeroProcess
	 *     NZCProcess returns ZeroProcess
	 *     NProcess returns ZeroProcess
	 *     ZeroProcess returns ZeroProcess
	 *
	 * Constraint:
	 *     {ZeroProcess}
	 */
	protected void sequence_ZeroProcess(ISerializationContext context, ZeroProcess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
