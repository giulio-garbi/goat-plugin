grammar com.sysma.goat.eclipse_plugin.GoatComponents with org.eclipse.xtext.common.Terminals

generate goatComponents "http://www.sysma.com/goat/eclipse_plugin/GoatComponents"

Model:
	{Model}
	(processes += ProcessDefinition |
	components += ComponentDefinition | 
	functions += FuncDefinition)*;

// Process
Proc returns Process:
	InterleavingProcess|NonDeterminismProcess
;

InterleavingProcess returns Process:
	CallProcess {InterleavingProcess.subProcs+=current} ("|" subProcs+=CallProcess)*
;

NonDeterminismProcess returns Process:
	//(PreconditionProcess ({NonDeterminismProcess.procLeft=current} "+" procRight=NonDeterminismProcess)?) |
	PredOutputProcessOrInputProcesses |
	IfProcesses |
	NProcess 
;

Preconditions:
	{Preconditions} (precond += (Update | Awareness))*
;

PredOutputProcessOrInputProcesses returns Process:
	Preconditions (
		({OutputProcess.precond = current} OutputProcessPart)|
		({InputProcesses.preconds += current} InputProcessesPart)
	)
;

PredOutputProcessOrInputProcess returns Process:
	Preconditions (
		({OutputProcess.precond = current} OutputProcessPart)|
		({InputProcesses.preconds += current} inputs += InputProcess)
	)
;

fragment InputProcessesPart:
	inputs += InputProcess ('+' preconds += Preconditions inputs += InputProcess)*
;

InputProcess returns Process:
	{InputProcess} "receive" "("rec_pred=Expression")" "{" (msgInParts+=AttributeToSet ("," msgInParts+=AttributeToSet)*)? "}" ("print" "(" output = STRING ")")? 
		"."next=NZCProcess
;

fragment OutputProcessPart:
	"send" "{" (msgOutParts+=Expression ("," msgOutParts+=Expression)*)? "}" "@" "("send_pred=Expression ")" ("print" "(" output = STRING ")")? 
	("sleep""("msec = INT")")?"."next=Proc	
;

IfProcesses returns Process:
	{IfProcesses} branches += IfBranchProcess ("else" branches += IfBranchProcess)*
;

IfBranchProcess returns Process:
	{IfBranchProcess} "if" cond = Preconditions '{' then = (PredOutputProcessOrInputProcess) '}'
;

Update:
	"[" vars += AttributeToSet ":=" vals += Expression ("," vars += AttributeToSet ":=" vals += Expression)* "]"  
;

Awareness:
	"wait""until""(" pred = Expression ")"
;

NZCProcess returns Process:
	"(" Proc ")" | ZeroProcess | CallProcess
;
	
NProcess returns Process:
	"(" Proc ")" | ZeroProcess //| CallProcess
;

CallProcess returns Process:
	{CallProcess}
	procname = [ProcessDefinition]
;

ZeroProcess returns Process:
	{ZeroProcess} "nil"
;

ProcessDefinition:
	'proc' name=ID '=' proc = Proc 
;

// Component
EnvInitValue returns Expression:
	{IntConstant} value=INT |
	{StringConstant} value=STRING |
	{BoolConstant} value=('true'|'false')
;

Environment:
	{Environment} "{"(attrs += ID ':=' vals+=EnvInitValue (","attrs += ID ':=' vals+=EnvInitValue)*)?"}"
;

ComponentDefinition:
	"component" env = Environment proc = [ProcessDefinition] 'at' address=STRING
;

/* 
// Predicate
Predicate returns Pred:
	And ({Predicate.or += current} "||" or += And)*
;
And returns Pred:
	Not ({And.and += current} "&&" and += Not)*
;
Not returns Pred:
	Term | {Not} neg?="!" term = Term
;
Term returns Pred:
	Immediate | EqualityTest | "(" Predicate ")" 
;
Immediate returns Pred:
	{Immediate} (isTrue ?= "true" | "false")
;
EqualityTest returns Pred:
	{EqualityTest} op1 = (Value|RecAttribute) operand=("<"|">"|"<="|">="|"="|"!=") op2 = Value
;
*/
// Expression
Expression: Or;

Or returns Expression:
	And ({Or.left=current} "||" right=And)?
;

And returns Expression:
	Equality ({And.left=current} "&&" right=Equality)?
;

Equality returns Expression:
	Comparison (
		{Equality.left=current} op=("=="|"!=")
		right=Comparison
	)?
;

Comparison returns Expression:
	PlusOrMinus (
		{Comparison.left=current} op=(">="|"<="|">"|"<")
		right=PlusOrMinus
	)?
;

PlusOrMinus returns Expression:
	MulOrDiv (
		({Plus.left=current} '+' | {Minus.left=current} '-' | {Concatenate.left=current} '++') 
		right=MulOrDiv
	)?
;

MulOrDiv returns Expression:
	Primary (
		{MulOrDiv.left=current} op=('*'|'/') 
		right=Primary
	)?
;

Primary returns Expression:
	'(' Expression ')' |
	{Not} "!" "("expression=Primary")" |
	Atomic
;

LRef:
	FuncParam|FuncVarDeclaration
;

Atomic returns Expression:
	{IntConstant} value=INT |
	{StringConstant} value=STRING |
	{BoolConstant} value=('true'|'false') |
	{LocalVarRef} ref=[LRef] |
	{LocalAttributeRef} "proc" "." attribute=ID |
	{FunctionCall} function=[FuncDefinition]"("(params+=Expression(","params+=Expression)*)?")"|
	{ComponentAttributeRef} "this""."attribute=ID |
	{RecAttributeRef} "receiver""."attribute=ID
;

AttributeToSet :
	{ComponentAttributeToSet} "this""."attribute=ID |
	{LocalAttributeToSet} "proc" "." attribute=ID 
;

terminal TYPE:
	('int'|'string'|'bool')
;

// Functions
FuncParam:
	type = TYPE name = ID
;
FuncDefinition:
	'function' type=TYPE name=ID '('(params+=FuncParam (',' params+=FuncParam)*)?')' blk = FuncBlock
;
FuncBlock:
	'{' {FuncBlock} (statements += FuncStatement)* '}'
;
FuncStatement:
	(FuncVarAssign | FuncIfElse | FuncReturn | FuncVarDeclaration) 
;

FuncVarDeclaration:
	'var' name = ID '=' val = Expression
;

FuncVarAssign:
	var = [FuncVarDeclaration] '=' val = Expression
;

FuncIfElse:
	'if' '('test += Expression')' then += FuncBlock
	('elif' '('test += Expression')' then += FuncBlock)*
	('else' elseBranch = FuncBlock)?
;
FuncReturn:
	'return' val = Expression
;